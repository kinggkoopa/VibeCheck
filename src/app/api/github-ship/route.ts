import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/lib/supabase/server";
import { checkApiRateLimit } from "@/lib/security";

/**
 * POST /api/github-ship — One-click GitHub shipping.
 *
 * Creates a branch, commits code, and opens a PR using the GitHub API
 * with the user's stored GitHub PAT.
 *
 * Body: {
 *   repo: "owner/repo",
 *   code: string,
 *   filename: string,
 *   title: string,
 *   description?: string,
 *   base_branch?: string (default: "main"),
 *   critique_notes?: string
 * }
 */
export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    const {
      data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const rateLimited = await checkApiRateLimit(user.id);
    if (rateLimited) return rateLimited;

    const body = await request.json();
    const {
      repo,
      code,
      filename,
      title,
      description,
      base_branch = "main",
      critique_notes,
    } = body;

    if (!repo || !code || !filename || !title) {
      return NextResponse.json(
        {
          error:
            "Required fields: repo (owner/repo), code, filename, title",
        },
        { status: 400 }
      );
    }

    // Get GitHub token from user settings (stored in user_settings table)
    const { data: settings } = await supabase
      .from("user_settings")
      .select("github_token")
      .eq("user_id", user.id)
      .single();

    const token = settings?.github_token;
    if (!token) {
      return NextResponse.json(
        {
          error:
            "No GitHub token configured. Add one in Settings → Integrations.",
        },
        { status: 400 }
      );
    }

    const headers = {
      Authorization: `Bearer ${token}`,
      Accept: "application/vnd.github+json",
      "X-GitHub-Api-Version": "2022-11-28",
      "Content-Type": "application/json",
    };

    const apiBase = "https://api.github.com";
    const [owner, repoName] = repo.split("/");

    if (!owner || !repoName) {
      return NextResponse.json(
        { error: "repo must be in format 'owner/repo'" },
        { status: 400 }
      );
    }

    // 1. Get base branch SHA
    const refRes = await fetch(
      `${apiBase}/repos/${owner}/${repoName}/git/ref/heads/${base_branch}`,
      { headers }
    );
    if (!refRes.ok) {
      const err = await refRes.text();
      return NextResponse.json(
        { error: `Failed to get base branch: ${err.slice(0, 200)}` },
        { status: 400 }
      );
    }
    const refData = (await refRes.json()) as {
      object: { sha: string };
    };
    const baseSha = refData.object.sha;

    // 2. Create branch
    const branchName = `metavibe/${filename.replace(/[^a-zA-Z0-9.-]/g, "-")}-${Date.now().toString(36)}`;
    const createBranchRes = await fetch(
      `${apiBase}/repos/${owner}/${repoName}/git/refs`,
      {
        method: "POST",
        headers,
        body: JSON.stringify({
          ref: `refs/heads/${branchName}`,
          sha: baseSha,
        }),
      }
    );
    if (!createBranchRes.ok) {
      const err = await createBranchRes.text();
      return NextResponse.json(
        { error: `Failed to create branch: ${err.slice(0, 200)}` },
        { status: 500 }
      );
    }

    // 3. Create or update file
    const createFileRes = await fetch(
      `${apiBase}/repos/${owner}/${repoName}/contents/${filename}`,
      {
        method: "PUT",
        headers,
        body: JSON.stringify({
          message: `feat: ${title}\n\nGenerated by MetaVibeCoder`,
          content: Buffer.from(code).toString("base64"),
          branch: branchName,
        }),
      }
    );
    if (!createFileRes.ok) {
      const err = await createFileRes.text();
      return NextResponse.json(
        { error: `Failed to create file: ${err.slice(0, 200)}` },
        { status: 500 }
      );
    }

    // 4. Create PR
    const prBody = [
      description ?? `Auto-generated code for: ${title}`,
      "",
      "---",
      "*Shipped via [MetaVibeCoder](https://github.com/kinggkoopa/VibeCheck)*",
    ];

    if (critique_notes) {
      prBody.splice(1, 0, "", "### Critique Notes", critique_notes);
    }

    const createPrRes = await fetch(
      `${apiBase}/repos/${owner}/${repoName}/pulls`,
      {
        method: "POST",
        headers,
        body: JSON.stringify({
          title: `[MetaVibe] ${title}`,
          body: prBody.join("\n"),
          head: branchName,
          base: base_branch,
        }),
      }
    );
    if (!createPrRes.ok) {
      const err = await createPrRes.text();
      return NextResponse.json(
        { error: `Failed to create PR: ${err.slice(0, 200)}` },
        { status: 500 }
      );
    }

    const prData = (await createPrRes.json()) as {
      html_url: string;
      number: number;
    };

    // Log analytics
    try {
      await supabase.from("analytics").insert({
        user_id: user.id,
        event_type: "github_ship",
        metadata: {
          repo,
          branch: branchName,
          pr_number: prData.number,
          filename,
        },
      });
    } catch {
      // Non-fatal
    }

    return NextResponse.json({
      data: {
        pr_url: prData.html_url,
        pr_number: prData.number,
        branch: branchName,
      },
      error: null,
    });
  } catch (err) {
    const message = err instanceof Error ? err.message : "Unknown error";
    return NextResponse.json({ data: null, error: message }, { status: 500 });
  }
}
